# Parsing

character -> **lexer** -> tokens ->**parser** -> parse tree

Parser must distinguish between valid and invalid tokens from the *lexer*.

**The problem:** programming languages have recursive structure such as nested "+" and "*" in arithmetic expressions.

**The solution:** define expression as either:
- a number
- an expression followed by an operator(such as `-, +, *, %`) followed by an expression
- `(` followed by an expression followed by `)`

An alternative notation:
```
E -> int
E -> E op E
E -> (E)
```

Every expression can be turned into a set of possible sub-expressions, for eample:
```
E -> E * E -> (E) * E -> (E + E) * E...
```

Any sequence of E forms a valid expression, conversely, any arithmetic expression can be turned into a sequence of E.

`(E))` will never be possible because the 2nd `)` will be rejected by the lexer.

The above notation is a <ins>**context-free grammar**.</ins>

## Context-Free Grammar(CFG)
A CFG consists of: `G = (N, T, S, R)`
- A set of non-terminals N
- A set of termianls T
  - Terminals can never be replaced by another symbol
- A start symbol S
- A set of productions R

### Key Idea:
Look at a string:
x<sub>i-2</sub>, x<sub>i-1</sub>, x<sub>i</sub>, x<sub>i+1</sub>, x<sub>i+2</sub>, ...
, if there is a production on, for example, x<sub>i</sub>, then replace it with the RHS of the production:
x<sub>i-2</sub>, x<sub>i-1</sub>, RHS, x<sub>i+1</sub>, x<sub>i+2</sub>, ...

Keep doing this until no more productions can be applied i.e. every x<sub>i</sub> is either turned into a terminal or a terminal itself.

## Parse Tree
A parse tree is a tree representation of a string that is generated by a CFG.

A sequence of productions(aka a *derivation*) is a sequence of productions that can be applied to a string to generate a parse tree.

Terminals are always at the leaves of the parse tree, connecting terminals at the leaves generates the original string.
